/**
 * @module values
 *
 * This module exports interfaces that model the API contract defined by the ArgoCD Helm chart `values.yaml`.
 *
 * This file is automatically generated by AI and should not be edited manually. To re-generate this file,
 * use the below prompt and append the default `values.yaml` of the ArgoCD Helm chart. The next time this file
 * is generated, you might also want to attach the current state to improve the chances the AI will produce
 * code consistent with the previous version. Note that you may need to attach the `values.yaml` file as an
 * attachment as it may be too large to fit in the prompt field directly.
 *
 * Last updated: 2025-06-05 using Gemini 2.5 Pro (preview)
 * Updated using ArgoCD Helm chart version: 8.0.14
 * See https://artifacthub.io/packages/helm/argo/argo-cd
 *
 * Prompt:
 *
 * ```
 * Generate TypeScript code that accurately models the API contract defined by the ArgoCD Helm chart `values.yaml`.
 * Follow these guidelines:
 *
 * 1. **Structure & Interface Design:**
 *   - Create the main exported interface named `ArgoCDChartValues`.
 *   - Output an `IngressConfig` interface for the server ingress configuration
 *   - Export all interfaces
 *   - Choose interface names that logically reflect the structure and hierarchy of the Helm values file.
 *   - Some example names include: `ServerConfig`, `IngressConfig`, `RepoServerConfig`, `ArgoCDConfigs`,
 *     `GlobalConfig`, `PDBConfig`, `ImageConfig`, etc.
 *
 * 2. **Typing & Special Cases:**
 *   - Match property names exactly as they appear in the values file.
 *   - For fields clearly representing secrets (e.g., containing `"password"`), use `SecretValue<string>` instead of
 *     `string`. Import `SecretValue` from `@gin/core`.
 *   - For free-form objects like labels or annotations, use `Record<string, ValueType>` as appropriate—**do not use
 *     `{[key: string]: ValueType}`**.
 *   - Prefer specific types where possible. If necessary, use `unknown` instead of `any`.
 *   - Resource limits and requests are typically `Record<string, string>`
 *
 * 3. **Documentation:**
 *   - Document each interface and property using comments from the values file.
 *   - Avoid repeating the property name or type in the documentation text.
 *   - Ensure to correctly type out standard Kubernetes concepts like Pod volumes and container volumeMounts, etc.
 *   - Links to other types should be in the format `{@link TypeName}` and `{@link TypeName#propertyName}` for properties.
 *     - Do not add a link to the type of a property into its own documentation.
 *
 * 4. **Coverage & Accuracy:**
 *   - Ensure the entire structure of the values file is reflected, including nested objects and arrays.
 *   - Infer structure from example values or comments (e.g., when a field has a default value of `{}` but a commented
 *     example follows, use that structure, such as for `deploymentStrategy`).
 *   - The final output must be valid TypeScript with no syntax errors.
 * ```
 */

import type { SecretValue } from "@gin/core";

// ##################################
// # Kubernetes Helper Interfaces   #
// ##################################

/**
 * Represents a Kubernetes resource requirement.
 */
export interface KubeResourceRequirement {
  /**
   * Describes the maximum amount of compute resources allowed.
   */
  limits?: Record<string, string>;
  /**
   * Describes the minimum amount of compute resources required.
   */
  requests?: Record<string, string>;
}

/**
 * Configuration for readiness or liveness probes.
 * Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
 */
export interface ProbeConfig {
  /**
   * Minimum consecutive failures for the [probe] to be considered failed after having succeeded
   */
  failureThreshold?: number;
  /**
   * Number of seconds after the container has started before [probe] is initiated
   */
  initialDelaySeconds?: number;
  /**
   * How often (in seconds) to perform the [probe]
   */
  periodSeconds?: number;
  /**
   * Minimum consecutive successes for the [probe] to be considered successful after having failed
   */
  successThreshold?: number;
  /**
   * Number of seconds after which the [probe] times out
   */
  timeoutSeconds?: number;
}

/**
 * PodDisruptionBudget configuration.
 * Ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
 */
export interface PDBConfig {
  /**
   * Deploy a [PodDisruptionBudget].
   */
  enabled?: boolean;
  /**
   * Labels to be added to the pdb.
   */
  labels?: Record<string, string>;
  /**
   * Annotations to be added to the pdb.
   */
  annotations?: Record<string, string>;
  /**
   * Number of pods that are available after eviction as number or percentage (eg.: 50%).
   * @default "" (defaults to 0 if not specified)
   */
  minAvailable?: string | number;
  /**
   * Number of pods that are unavailable after eviction as number or percentage (eg.: 50%).
   * Has higher precedence over `minAvailable`.
   */
  maxUnavailable?: string | number;
}

/**
 * Kubernetes Volume configuration.
 * Ref: https://kubernetes.io/docs/concepts/storage/volumes/
 */
export interface Volume {
  name: string;
  [key: string]: unknown;
}

/**
 * Kubernetes VolumeMount configuration.
 * Ref: https://kubernetes.io/docs/concepts/storage/volumes/
 */
export interface VolumeMount {
  name: string;
  mountPath: string;
  subPath?: string;
  [key: string]: unknown;
}

/**
 * Kubernetes container-level security context.
 * Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 */
export interface ContainerSecurityContext {
  runAsNonRoot?: boolean;
  readOnlyRootFilesystem?: boolean;
  allowPrivilegeEscalation?: boolean;
  runAsUser?: number;
  seccompProfile?: {
    type?: "RuntimeDefault" | "Unconfined" | "Localhost";
    [key: string]: unknown;
  };
  capabilities?: {
    drop?: string[];
    [key: string]: unknown;
  };
}

/**
 * Kubernetes pod-level security context.
 * Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
 */
export interface PodSecurityContext {
  runAsUser?: number;
  runAsGroup?: number;
  fsGroup?: number;
  seccompProfile?: {
    type?: "RuntimeDefault" | "Unconfined" | "Localhost";
    [key: string]: unknown;
  };
  [key: string]: unknown;
}

/**
 * Kubernetes toleration configuration.
 * Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
 */
export interface Toleration {
  key?: string;
  operator?: string;
  value?: string;
  effect?: string;
  tolerationSeconds?: number;
}

/**
 * Configuration for Horizontal Pod Autoscaler.
 * Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
 */
export interface HPAConfig {
  /**
   * Enable Horizontal Pod Autoscaler ([HPA]).
   */
  enabled?: boolean;
  /**
   * Minimum number of replicas for the [HPA].
   */
  minReplicas?: number;
  /**
   * Maximum number of replicas for the [HPA].
   */
  maxReplicas?: number;
  /**
   * Average CPU utilization percentage for the [HPA].
   */
  targetCPUUtilizationPercentage?: number;
  /**
   * Average memory utilization percentage for the [HPA].
   */
  targetMemoryUtilizationPercentage?: number;
  /**
   * Configures the scaling behavior of the target in both Up and Down directions.
   */
  behavior?: Record<string, unknown>;
  /**
   * Configures custom HPA metrics.
   * Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
   */
  metrics?: unknown[];
}

/**
 * A single an ingress host configuration.
 */
export interface IngressHost {
  name: string;
  path: string;
}

/**
 * A single ingress path configuration.
 */
export interface IngressPath {
  path: string;
  pathType: "Exact" | "Prefix" | "ImplementationSpecific";
  backend: {
    service: {
      name: string;
      port: {
        name: string;
      };
    };
  };
}

/**
 * A single ingress rule configuration.
 */
export interface IngressRule {
  http: {
    paths: IngressPath[];
  };
}

/**
 * A single ingress TLS configuration.
 */
export interface IngressTLS {
  hosts: string[];
  secretName: string;
}

/**
 * Defines the structure for Prometheus ServiceMonitor.
 */
export interface ServiceMonitorConfig {
  /**
   * Enable a prometheus ServiceMonitor.
   */
  enabled?: boolean;
  /**
   * Prometheus ServiceMonitor interval.
   */
  interval?: string;
  /**
   * Prometheus ServiceMonitor scrapeTimeout. If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
   */
  scrapeTimeout?: string;
  /**
   * When true, honorLabels preserves the metric’s labels when they collide with the target’s labels.
   */
  honorLabels?: boolean;
  /**
   * Prometheus [RelabelConfigs] to apply to samples before scraping.
   */
  relabelings?: unknown[];
  /**
   * Prometheus [MetricRelabelConfigs] to apply to samples before ingestion.
   */
  metricRelabelings?: unknown[];
  /**
   * Prometheus ServiceMonitor selector.
   */
  selector?: Record<string, string>;
  /**
   * Prometheus ServiceMonitor scheme.
   */
  scheme?: string;
  /**
   * Prometheus ServiceMonitor tlsConfig.
   */
  tlsConfig?: Record<string, unknown>;
  /**
   * Prometheus ServiceMonitor namespace.
   */
  namespace?: string;
  /**
   * Prometheus ServiceMonitor labels.
   */
  additionalLabels?: Record<string, string>;
  /**
   * Prometheus ServiceMonitor annotations.
   */
  annotations?: Record<string, string>;
}

// ##################################
// # ArgoCD Main Interfaces         #
// ##################################

/**
 * Image configuration.
 */
export interface ImageConfig {
  /**
   * If defined, a repository applied to all Argo CD deployments.
   */
  repository?: string;
  /**
   * Overrides the global Argo CD image tag whose default is the chart appVersion.
   */
  tag?: string;
  /**
   * If defined, a imagePullPolicy applied to all Argo CD deployments.
   */
  imagePullPolicy?: "Always" | "IfNotPresent" | "Never";
}

/**
 * Logging configuration.
 */
export interface LoggingConfig {
  /**
   * Set the global logging format. Either: `text` or `json`.
   */
  format?: "text" | "json";
  /**
   * Set the global logging level. One of: `debug`, `info`, `warn` or `error`.
   */
  level?: "debug" | "info" | "warn" | "error";
}

/**
 * Affinity configuration.
 */
export interface AffinityConfig {
  /**
   * Default pod anti-affinity rules. Either: `none`, `soft` or `hard`.
   */
  podAntiAffinity?: "none" | "soft" | "hard";
  /**
   * Node affinity rules.
   */
  nodeAffinity?: {
    /**
     * Default node affinity rules. Either: `none`, `soft` or `hard`.
     */
    type?: "none" | "soft" | "hard";
    /**
     * Default match expressions for node affinity.
     */
    matchExpressions?: {
      key: string;
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist";
      values: string[];
    }[];
  };
}

/**
 * Topology spread constraint configuration.
 * Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
 */
export interface TopologySpreadConstraint {
  maxSkew?: number;
  topologyKey: string;
  whenUnsatisfiable: "DoNotSchedule" | "ScheduleAnyway";
  labelSelector?: Record<string, string>;
}

/**
 * Configuration for `argocd-cm` ConfigMap.
 * Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
 */
export interface CMConfig {
  /**
   * Create the argocd-cm configmap for [declarative setup].
   */
  create?: boolean;
  /**
   * Annotations to be added to argocd-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * The name of tracking label used by Argo CD for resource pruning.
   */
  "application.instanceLabelKey"?: string;
  /**
   * Enable control of the service account used for the sync operation (alpha).
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/app-sync-using-impersonation/
   */
  "application.sync.impersonation.enabled"?: boolean;
  /**
   * Enable logs RBAC enforcement.
   * Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/upgrading/2.3-2.4/#enable-logs-rbac-enforcement
   */
  "server.rbac.log.enforce.enable"?: boolean;
  /**
   * Enable exec feature in Argo UI.
   * Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/rbac/#exec-resource
   */
  "exec.enabled"?: boolean;
  /**
   * Enable local admin user.
   * Ref: https://argo-cd.readthedocs.io/en/latest/faq/#how-to-disable-admin-user
   */
  "admin.enabled"?: boolean;
  /**
   * Timeout to discover if a new manifests version got published to the repository.
   */
  "timeout.reconciliation"?: string;
  /**
   * Timeout to refresh application data as well as target manifests cache.
   */
  "timeout.hard.reconciliation"?: string;
  /**
   * Enable Status Badge.
   * Ref: https://argo-cd.readthedocs.io/en/stable/user-guide/status-badge/
   */
  "statusbadge.enabled"?: boolean;
  /**
   * Dex configuration.
   */
  "dex.config"?: string;
  /**
   * OIDC configuration as an alternative to dex (optional).
   */
  "oidc.config"?: string;
  /**
   * Extension Configuration.
   * Ref: https://argo-cd.readthedocs.io/en/latest/developer-guide/extensions/proxy-extensions/
   */
  "extension.config"?: string;
  /**
   * Ignoring status for all resources. An update will still be sent if the status update causes the health to change.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.all"?: string;
  /**
   * Some Application fields are generated and not related to the application updates itself.
   * The Application itself is already watched by the controller lister, but this configuration is applied for apps of apps.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.argoproj.io_Application"?: string;
  /**
   * Ignore Argo Rollouts generated fields.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.argoproj.io_Rollout"?: string;
  /**
   * Legacy annotations used on HPA autoscaling/v1.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.autoscaling_HorizontalPodAutoscaler"?: string;
  /**
   * Ignore the cluster-autoscaler status.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.ConfigMap"?: string;
  /**
   * Ignore the common scaling annotations.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.apps_ReplicaSet"?: string;
  /**
   * Ignores update if EndpointSlice is not excluded globally.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.discovery.k8s.io_EndpointSlice"?: string;
  /**
   * Ignores update if Endpoints is not excluded globally.
   * @default See [values.yaml]
   */
  "resource.customizations.ignoreResourceUpdates.Endpoints"?: string;
  /**
   * Resource Exclusion/Inclusion.
   * @default See [values.yaml]
   */
  "resource.exclusions"?: string;
  [key: string]: unknown;
}

/**
 * Argo CD command parameters configuration.
 * Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cmd-params-cm.yaml
 */
export interface ParamsConfig {
  /**
   * Create the argocd-cmd-params-cm configmap.
   * If false, it is expected the configmap will be created by something else.
   */
  create?: boolean;
  /**
   * Annotations to be added to the argocd-cmd-params-cm ConfigMap.
   */
  annotations?: Record<string, string>;
  /**
   * Open-Telemetry collector address: (e.g. "otel-collector:4317").
   */
  "otlp.address"?: string;
  /**
   * Number of application status processors.
   */
  "controller.status.processors"?: number;
  /**
   * Number of application operation processors.
   */
  "controller.operation.processors"?: number;
  /**
   * Specifies timeout between application self heal attempts.
   */
  "controller.self.heal.timeout.seconds"?: number;
  /**
   * Repo server RPC call timeout seconds.
   */
  "controller.repo.server.timeout.seconds"?: number;
  /**
   * Specifies the timeout after which a sync would be terminated. 0 means no timeout.
   */
  "controller.sync.timeout.seconds"?: number;
  /**
   * Run server without TLS.
   * NOTE: This value should be set when you generate params by other means as it changes ports used by ingress template.
   */
  "server.insecure"?: boolean;
  /**
   * Value for base href in index.html. Used if Argo CD is running behind reverse proxy under subpath different from /.
   */
  "server.basehref"?: string;
  /**
   * Used if Argo CD is running behind reverse proxy under subpath different from /.
   */
  "server.rootpath"?: string;
  /**
   * Directory path that contains additional static assets.
   */
  "server.staticassets"?: string;
  /**
   * Disable Argo CD RBAC for user authentication.
   */
  "server.disable.auth"?: boolean;
  /**
   * Enable GZIP compression.
   */
  "server.enable.gzip"?: boolean;
  /**
   * Enable proxy extension feature. (proxy extension is in Alpha phase).
   */
  "server.enable.proxy.extension"?: boolean;
  /**
   * Enable the hydrator feature (hydrator is in Alpha phase).
   */
  "hydrator.enabled"?: boolean;
  /**
   * Set X-Frame-Options header in HTTP responses to value. To disable, set to "".
   */
  "server.x.frame.options"?: string;
  /**
   * Limit on number of concurrent manifests generate requests. Any value less the 1 means no limit.
   */
  "reposerver.parallelism.limit"?: number;
  /**
   * Modify how application is synced between the generator and the cluster. One of: `sync`, `create-only`, `create-update`, `create-delete`.
   */
  "applicationsetcontroller.policy"?: "sync" | "create-only" | "create-update" | "create-delete";
  /**
   * Enables use of the Progressive Syncs capability.
   */
  "applicationsetcontroller.enable.progressive.syncs"?: boolean;
  /**
   * A list of glob patterns specifying where to look for ApplicationSet resources. (e.g. `"argocd,argocd-appsets-*"`)
   * @default "" (default is only the ns where the controller is installed)
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Appset-Any-Namespace/
   */
  "applicationsetcontroller.namespaces"?: string;
  /**
   * Enables [Applications in any namespace].
   * List of additional namespaces where applications may be created in and reconciled from.
   * The namespace where Argo CD is installed to will always be allowed.
   * Set comma-separated list. (e.g. app-team-one, app-team-two)
   */
  "application.namespaces"?: string;
  /**
   * JQ Path expression timeout.
   * By default, the evaluation of a JQPathExpression is limited to one second.
   * If you encounter a "JQ patch execution timed out" error message due to a complex JQPathExpression
   * that requires more time to evaluate, you can extend the timeout period.
   */
  "controller.ignore.normalizer.jq.timeout"?: string;
}

/**
 * Argo CD RBAC policy configuration.
 * Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/rbac.md
 */
export interface RBACConfig {
  /**
   * Create the argocd-rbac-cm configmap with ([Argo CD RBAC policy]) definitions.
   * If false, it is expected the configmap will be created by something else.
   * Argo CD will not work if there is no configmap created with the name above.
   */
  create?: boolean;
  /**
   * Annotations to be added to argocd-rbac-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * The name of the default role which Argo CD will falls back to, when authorizing API requests (optional).
   * If omitted or empty, users may be still be able to login, but will see no apps, projects, etc...
   */
  "policy.default"?: string;
  /**
   * File containing user-defined policies and role definitions.
   * @default '' (See [values.yaml])
   */
  "policy.csv"?: string;
  /**
   * OIDC scopes to examine during rbac enforcement (in addition to `sub` scope).
   * The scope value can be a string, or a list of strings.
   */
  scopes?: string;
  /**
   * Matcher function for Casbin, `glob` for glob matcher and `regex` for regex matcher.
   */
  "policy.matchMode"?: "glob" | "regex";
}

/**
 * GnuPG public keys for commit verification.
 * Ref: https://argo-cd.readthedocs.io/en/stable/user-guide/gpg-verification/
 */
export interface GPGConfig {
  /**
   * Annotations to be added to argocd-gpg-keys-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * [GnuPG] public keys to add to the keyring.
   * Note: Public keys should be exported with `gpg --export --armor <KEY>`.
   * @default {} (See [values.yaml])
   */
  keys?: Record<string, string>;
}

/**
 * SSH known hosts for Git repositories.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#ssh-known-host-public-keys
 */
export interface SSHConfig {
  /**
   * Specifies if the argocd-ssh-known-hosts-cm configmap should be created by Helm.
   */
  create?: boolean;
  /**
   * Annotations to be added to argocd-ssh-known-hosts-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * Known hosts to be added to the known host list by default.
   * @default See [values.yaml]
   */
  knownHosts?: string;
  /**
   * Additional known hosts for private repositories.
   */
  extraHosts?: string;
}

/**
 * Repository TLS certificates.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#repositories-using-self-signed-tls-certificates-or-are-signed-by-custom-ca
 */
export interface TLSConfig {
  /**
   * Annotations to be added to argocd-tls-certs-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * TLS certificates for Git repositories.
   * @default {} (See [values.yaml])
   */
  certificates?: Record<string, string>;
  /**
   * Specifies if the argocd-tls-certs-cm configmap should be created by Helm.
   */
  create?: boolean;
}

/**
 * ConfigMap for Config Management Plugins.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/config-management-plugins/
 */
export interface CMPConfig {
  /**
   * Create the argocd-cmp-cm configmap.
   */
  create?: boolean;
  /**
   * Annotations to be added to argocd-cmp-cm configmap.
   */
  annotations?: Record<string, string>;
  /**
   * Plugin yaml files to be added to argocd-cmp-cm.
   */
  plugins?: Record<string, unknown>;
}

/**
 * Configuration for a single external cluster credential.
 */
export interface ClusterCredential {
  server: string;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
  namespaces?: string;
  clusterResources?: boolean;
  project?: string;
  shard?: number;
  config: {
    bearerToken: SecretValue<string>;
    tlsClientConfig: {
      insecure: boolean;
      caData: SecretValue<string>;
    };
  };
}

/**
 * Configuration for a repository credential template.
 */
export interface CredentialTemplate {
  url: string;
  githubAppID?: number;
  githubAppInstallationID?: number;
  githubAppEnterpriseBaseUrl?: string;
  githubAppPrivateKey?: SecretValue<string>;
  password?: SecretValue<string>;
  username?: string;
  sshPrivateKey?: SecretValue<string>;
}

/**
 * Configuration for a single repository.
 */
export interface Repository {
  url: string;
  name?: string;
  type?: "helm" | "git";
  password?: SecretValue<string>;
  username?: string;
}

/**
 * Argo CD sensitive data configuration.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sensitive-data-and-sso-client-secrets
 */
export interface SecretConfig {
  /**
   * Create the argocd-secret.
   */
  createSecret?: boolean;
  /**
   * Labels to be added to argocd-secret.
   */
  labels?: Record<string, string>;
  /**
   * Annotations to be added to argocd-secret.
   */
  annotations?: Record<string, string>;
  /**
   * Shared secret for authenticating GitHub webhook events.
   */
  githubSecret?: SecretValue<string>;
  /**
   * Shared secret for authenticating GitLab webhook events.
   */
  gitlabSecret?: SecretValue<string>;
  /**
   * Shared secret for authenticating BitbucketServer webhook events.
   */
  bitbucketServerSecret?: SecretValue<string>;
  /**
   * UUID for authenticating Bitbucket webhook events.
   */
  bitbucketUUID?: string;
  /**
   * Shared secret for authenticating Gogs webhook events.
   */
  gogsSecret?: SecretValue<string>;
  /**
   * Azure DevOps webhook configuration.
   */
  azureDevops?: {
    /**
     * Shared secret username for authenticating Azure DevOps webhook events.
     */
    username?: string;
    /**
     * Shared secret password for authenticating Azure DevOps webhook events.
     */
    password?: SecretValue<string>;
  };
  /**
   * add additional secrets to be added to argocd-secret.
   * Custom secrets. Useful for injecting SSO secrets into environment variables.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/user-management/#sensitive-data-and-sso-client-secrets
   * Note that all values must be non-empty.
   */
  extra?: Record<string, SecretValue<string>>;
  /**
   * Bcrypt hashed admin password.
   * Argo expects the password in the secret to be bcrypt hashed. You can create this hash with
   * `htpasswd -nbBC 10 "" $ARGO_PWD | tr -d ':\n' | sed 's/$2y/$2a/'`
   */
  argocdServerAdminPassword?: SecretValue<string>;
  /**
   * Admin password modification time. Eg. `"2006-01-02T15:04:05Z"`.
   * @default "" (defaults to current time)
   */
  argocdServerAdminPasswordMtime?: string;
}

/**
 * Argo CD configuration.
 */
export interface ArgoCDConfigs {
  /**
   * General Argo CD configuration. Any values you put under `.configs.cm` are passed to argocd-cm ConfigMap.
   * {@link CMConfig}
   */
  cm?: CMConfig;
  /**
   * Argo CD configuration parameters.
   * {@link ParamsConfig}
   */
  params?: ParamsConfig;
  /**
   * Argo CD RBAC policy configuration.
   * {@link RBACConfig}
   */
  rbac?: RBACConfig;
  /**
   * GnuPG public keys for commit verification.
   * {@link GPGConfig}
   */
  gpg?: GPGConfig;
  /**
   * SSH known hosts for Git repositories.
   * {@link SSHConfig}
   */
  ssh?: SSHConfig;
  /**
   * Repository TLS certificates.
   * {@link TLSConfig}
   */
  tls?: TLSConfig;
  /**
   * ConfigMap for Config Management Plugins.
   * {@link CMPConfig}
   */
  cmp?: CMPConfig;
  /**
   * Provide one or multiple [external cluster credentials].
   * @default {} (See [values.yaml])
   * Ref:
   * - https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#clusters
   * - https://argo-cd.readthedocs.io/en/stable/operator-manual/security/#external-cluster-credentials
   * - https://argo-cd.readthedocs.io/en/stable/user-guide/projects/#project-scoped-repositories-and-clusters
   */
  clusterCredentials?: Record<string, ClusterCredential>;
  /**
   * Repository credentials to be used as Templates for other repos.
   * Creates a secret for each key/value specified below to create repository credentials.
   */
  credentialTemplates?: Record<string, CredentialTemplate>;
  /**
   * Annotations to be added to `configs.credentialTemplates` Secret.
   */
  credentialTemplatesAnnotations?: Record<string, string>;
  /**
   * Repositories list to be used by applications.
   * Creates a secret for each key/value specified below to create repositories.
   * Note: the last example in the list would use a repository credential template, configured under "configs.credentialTemplates".
   */
  repositories?: Record<string, Repository>;
  /**
   * Annotations to be added to `configs.repositories` Secret.
   */
  repositoriesAnnotations?: Record<string, string>;
  /**
   * Argo CD sensitive data.
   * {@link SecretConfig}
   */
  secret?: SecretConfig;
  /**
   * Define custom [CSS styles] for your argo instance.
   * This setting will automatically mount the provided CSS and reference it in the argo configuration.
   * @default "" (See [values.yaml])
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/custom-styles/
   */
  styles?: string;
}

/**
 * Service account configuration.
 */
export interface ServiceAccountConfig {
  /**
   * Create a service account.
   */
  create?: boolean;
  /**
   * Service account name.
   */
  name?: string;
  /**
   * Annotations applied to created service account.
   */
  annotations?: Record<string, string>;
  /**
   * Labels applied to created service account.
   */
  labels?: Record<string, string>;
  /**
   * Automount API credentials for the Service Account.
   */
  automountServiceAccountToken?: boolean;
}

/**
 * Globally shared configuration.
 */
export interface GlobalConfig {
  /**
   * Default domain used by all components.
   * Used for ingresses, certificates, SSO, notifications, etc.
   */
  domain?: string;
  /**
   * Runtime class name for all components.
   */
  runtimeClassName?: string;
  /**
   * Common labels for the all resources.
   */
  additionalLabels?: Record<string, string>;
  /**
   * Number of old deployment ReplicaSets to retain. The rest will be garbage collected.
   */
  revisionHistoryLimit?: number;
  /**
   * Default image used by all components.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Default logging options used by all components.
   * {@link LoggingConfig}
   */
  logging?: LoggingConfig;
  /**
   * Annotations for the all deployed Statefulsets.
   */
  statefulsetAnnotations?: Record<string, string>;
  /**
   * Annotations for the all deployed Deployments.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations for the all deployed pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels for the all deployed pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Add Prometheus scrape annotations to all metrics services. This can be used as an alternative to the ServiceMonitors.
   */
  addPrometheusAnnotations?: boolean;
  /**
   * Toggle and define pod-level security context.
   * @default {} (See [values.yaml])
   * {@link PodSecurityContext}
   */
  securityContext?: PodSecurityContext;
  /**
   * Mapping between IP and hostnames that will be injected as entries in the pod's hosts files.
   */
  hostAliases?: { ip: string; hostnames: string[] }[];
  /**
   * Configure dual-stack used by all component services.
   */
  dualStack?: {
    /**
     * IP family policy to configure dual-stack see [Configure dual-stack](https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services).
     */
    ipFamilyPolicy?: string;
    /**
     * IP families that should be supported and the order in which they should be applied to ClusterIP as well. Can be IPv4 and/or IPv6.
     */
    ipFamilies?: ("IPv4" | "IPv6")[];
  };
  /**
   * Default network policy rules used by all components.
   */
  networkPolicy?: {
    /**
     * Create NetworkPolicy objects for all components.
     */
    create?: boolean;
    /**
     * Default deny all ingress traffic.
     */
    defaultDenyIngress?: boolean;
  };
  /**
   * Default priority class for all components.
   */
  priorityClassName?: string;
  /**
   * Default node selector for all components.
   */
  nodeSelector?: Record<string, string>;
  /**
   * Default tolerations for all components.
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Default affinity preset for all components.
   * {@link AffinityConfig}
   */
  affinity?: AffinityConfig;
  /**
   * Default [TopologySpreadConstraints] rules for all components.
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy for the all deployed Deployments.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
  /**
   * Environment variables to pass to all deployed Deployments.
   */
  env?: { name: string; value: string }[];
  /**
   * Annotations for the all deployed Certificates.
   */
  certificateAnnotations?: Record<string, string>;
}

/**
 * Controller metrics configuration.
 */
export interface ControllerMetricsConfig {
  /**
   * Deploy metrics service.
   */
  enabled?: boolean;
  /**
   * Prometheus ServiceMonitor scrapeTimeout. If empty, Prometheus uses the global scrape timeout unless it is less than the target's scrape interval value in which the latter is used.
   */
  scrapeTimeout?: string;
  applicationLabels?: {
    /**
     * Enables additional labels in argocd_app_labels metric.
     */
    enabled?: boolean;
    /**
     * Additional labels.
     */
    labels?: string[];
  };
  service?: {
    /**
     * Metrics service type.
     */
    type?: "ClusterIP" | "NodePort" | "LoadBalancer";
    /**
     * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
     */
    clusterIP?: string;
    /**
     * Metrics service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * Metrics service labels.
     */
    labels?: Record<string, string>;
    /**
     * Metrics service port.
     */
    servicePort?: number;
    /**
     * Metrics service port name.
     */
    portName?: string;
  };
  /**
   * Service monitor configuration.
   * {@link ServiceMonitorConfig}
   */
  serviceMonitor?: ServiceMonitorConfig;
  rules?: {
    /**
     * Deploy a PrometheusRule for the application controller.
     */
    enabled?: boolean;
    /**
     * PrometheusRule namespace.
     */
    namespace?: string;
    /**
     * PrometheusRule selector.
     */
    selector?: Record<string, string>;
    /**
     * PrometheusRule labels.
     */
    additionalLabels?: Record<string, string>;
    /**
     * PrometheusRule annotations.
     */
    annotations?: Record<string, string>;
    /**
     * PrometheusRule.Spec for the application controller.
     */
    spec?: unknown[];
  };
}

/**
 * Application controller configuration.
 */
export interface ControllerConfig {
  /**
   * Application controller name string.
   */
  name?: string;
  /**
   * The number of application controller pods to run.
   * Additional replicas will cause sharding of managed clusters across number of replicas.
   * With dynamic cluster distribution turned on, sharding of the clusters will gracefully
   * rebalance if the number of replica's changes or one becomes unhealthy. (alpha)
   */
  replicas?: number;
  /**
   * Enable dynamic cluster distribution (alpha).
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/dynamic-cluster-distribution
   * This is done using a deployment instead of a statefulSet.
   * When replicas are added or removed, the sharding algorithm is re-run to ensure that the
   * clusters are distributed according to the algorithm. If the algorithm is well-balanced,
   * like round-robin, then the shards will be well-balanced.
   */
  dynamicClusterDistribution?: boolean;
  /**
   * Runtime class name for the application controller.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * Application controller heartbeat time.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/dynamic-cluster-distribution/#working-of-dynamic-distribution
   */
  heartbeatTime?: number;
  /**
   * Maximum number of controller revisions that will be maintained in StatefulSet history.
   */
  revisionHistoryLimit?: number;
  /**
   * Application controller Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Application controller image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Additional command line arguments to pass to application controller.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to application controller.
   */
  env?: { name: string; value: string }[];
  /**
   * envFrom to pass to application controller.
   * @default [] (See [values.yaml])
   */
  envFrom?: unknown[];
  /**
   * Additional containers to be added to the application controller pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the application controller pod.
   * Note: Supports use of custom Helm templates.
   */
  initContainers?: unknown[];
  /**
   * Additional volumeMounts to the application controller main container.
   * {@link VolumeMount}
   */
  volumeMounts?: VolumeMount[];
  /**
   * Additional volumes to the application controller pod.
   * {@link Volume}
   */
  volumes?: Volume[];
  /**
   * Application controller emptyDir volumes.
   */
  emptyDir?: {
    /**
     * EmptyDir size limit for application controller.
     * @default "" (defaults not set if not specified i.e. no size limit)
     */
    sizeLimit?: string;
  };
  /**
   * Annotations for the application controller StatefulSet.
   */
  statefulsetAnnotations?: Record<string, string>;
  /**
   * Annotations for the application controller Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be added to application controller pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be added to application controller pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the application controller pods.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Application controller container ports.
   */
  containerPorts?: {
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * Host Network for application controller pods.
   */
  hostNetwork?: boolean;
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for application controller pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Application controller container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Readiness probe for application controller.
   * {@link ProbeConfig}
   */
  readinessProbe?: ProbeConfig;
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * Priority class for the application controller pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules to the deployment.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the application controller.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Application controller metrics configuration.
   * {@link ControllerMetricsConfig}
   */
  metrics?: ControllerMetricsConfig;
  /**
   * Enable this and set the rules: to whatever custom rules you want for the Cluster Role resource.
   * Defaults to off.
   */
  clusterRoleRules?: {
    /**
     * Enable custom rules for the application controller's ClusterRole resource.
     */
    enabled?: boolean;
    /**
     * List of custom rules for the application controller's ClusterRole resource.
     */
    rules?: unknown[];
  };
}

/**
 * Dex server configuration.
 */
export interface DexConfig {
  /**
   * Enable dex.
   */
  enabled?: boolean;
  /**
   * Dex name.
   */
  name?: string;
  /**
   * Additional command line arguments to pass to the Dex server.
   */
  extraArgs?: string[];
  /**
   * Runtime class name for Dex.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  metrics?: {
    /**
     * Deploy metrics service.
     */
    enabled?: boolean;
    service?: {
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: ServiceMonitorConfig;
  };
  /**
   * Dex Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Dex image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Argo CD init image that creates Dex config.
   */
  initImage?: ImageConfig & {
    /**
     * Argo CD init image resources.
     * @default {} (defaults to dex.resources)
     * {@link KubeResourceRequirement}
     */
    resources?: KubeResourceRequirement;
  };
  /**
   * Environment variables to pass to the Dex server.
   */
  env?: { name: string; value: string }[];
  /**
   * envFrom to pass to the Dex server.
   * @default [] (See [values.yaml])
   */
  envFrom?: unknown[];
  /**
   * Additional containers to be added to the dex pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the dex pod.
   * Note: Supports use of custom Helm templates.
   */
  initContainers?: unknown[];
  /**
   * Additional volumeMounts to the dex main container.
   * {@link VolumeMount}
   */
  volumeMounts?: VolumeMount[];
  /**
   * Additional volumes to the dex pod.
   * {@link Volume}
   */
  volumes?: Volume[];
  /**
   * Dex server emptyDir volumes.
   */
  emptyDir?: {
    /**
     * EmptyDir size limit for Dex server.
     * @default "" (defaults not set if not specified i.e. no size limit)
     */
    sizeLimit?: string;
  };
  /**
   * TLS certificate configuration via Secret.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/tls/#configuring-tls-to-argocd-dex-server
   * Note: Issuing certificates via cert-manager in not supported right now because it's not possible to restart Dex automatically without extra controllers.
   */
  certificateSecret?: {
    /**
     * Create argocd-dex-server-tls secret.
     */
    enabled?: boolean;
    /**
     * Labels to be added to argocd-dex-server-tls secret.
     */
    labels?: Record<string, string>;
    /**
     * Annotations to be added to argocd-dex-server-tls secret.
     */
    annotations?: Record<string, string>;
    /**
     * Certificate authority. Required for self-signed certificates.
     */
    ca?: string;
    /**
     * Certificate private key.
     */
    key?: SecretValue<string>;
    /**
     * Certificate data. Must contain SANs of Dex service (ie: argocd-dex-server, argocd-dex-server.argo-cd.svc).
     */
    crt?: string;
  };
  /**
   * Annotations to be added to the Dex server Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be added to the Dex server pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be added to the Dex server pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for dex.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Dex container ports.
   * NOTE: These ports are currently hardcoded and cannot be changed.
   */
  containerPorts?: {
    /**
     * HTTP container port.
     */
    http?: number;
    /**
     * gRPC container port.
     */
    grpc?: number;
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for Dex server pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Dex container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Probes for Dex server. Supported from Dex >= 2.28.0.
   */
  livenessProbe?: ProbeConfig & {
    enabled?: boolean;
    httpPath?: string;
    httpPort?: "metrics" | number;
    httpScheme?: "HTTP" | "HTTPS";
  };
  /**
   * Probes for Dex server. Supported from Dex >= 2.28.0.
   */
  readinessProbe?: ProbeConfig & {
    enabled?: boolean;
    httpPath?: string;
    httpPort?: "metrics" | number;
    httpScheme?: "HTTP" | "HTTPS";
  };
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Service port for HTTP access.
   */
  servicePortHttp?: number;
  /**
   * Service port name for HTTP access.
   */
  servicePortHttpName?: string;
  /**
   * Service port for gRPC access.
   */
  servicePortGrpc?: number;
  /**
   * Service port name for gRPC access.
   */
  servicePortGrpcName?: string;
  /**
   * Service port for metrics access.
   */
  servicePortMetrics?: number;
  /**
   * Priority class for the dex pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules to the deployment.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to dex.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the Dex server Deployment.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
}

/**
 * Redis configuration.
 */
export interface RedisConfig {
  /**
   * Enable redis.
   */
  enabled?: boolean;
  /**
   * Redis name.
   */
  name?: string;
  /**
   * Runtime class name for redis.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * Redis Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Redis image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Prometheus redis-exporter sidecar.
   */
  exporter?: {
    /**
     * Enable Prometheus redis-exporter sidecar.
     */
    enabled?: boolean;
    /**
     * Environment variables to pass to the Redis exporter.
     */
    env?: { name: string; value: string }[];
    /**
     * Prometheus redis-exporter image.
     * {@link ImageConfig}
     */
    image?: ImageConfig;
    /**
     * Redis exporter security context.
     * @default See [values.yaml]
     * {@link ContainerSecurityContext}
     */
    containerSecurityContext?: ContainerSecurityContext;
    /**
     * Probes for Redis exporter (optional).
     */
    readinessProbe?: ProbeConfig & { enabled?: boolean };
    /**
     * Probes for Redis exporter (optional).
     */
    livenessProbe?: ProbeConfig & { enabled?: boolean };
    /**
     * Resource limits and requests for redis-exporter sidecar.
     * {@link KubeResourceRequirement}
     */
    resources?: KubeResourceRequirement;
  };
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Additional command line arguments to pass to redis-server.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to the Redis server.
   */
  env?: { name: string; value: string }[];
  /**
   * envFrom to pass to the Redis server.
   * @default [] (See [values.yaml])
   */
  envFrom?: unknown[];
  /**
   * Probes for Redis server (optional).
   */
  readinessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * Probes for Redis server (optional).
   */
  livenessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * Additional containers to be added to the redis pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the redis pod.
   * Note: Supports use of custom Helm templates.
   */
  initContainers?: unknown[];
  /**
   * Additional volumeMounts to the redis container.
   * {@link VolumeMount}
   */
  volumeMounts?: VolumeMount[];
  /**
   * Additional volumes to the redis pod.
   * {@link Volume}
   */
  volumes?: Volume[];
  /**
   * Annotations to be added to the Redis server Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be added to the Redis server pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be added to the Redis server pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for redis.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Redis pod-level security context.
   * @default See [values.yaml]
   * {@link PodSecurityContext}
   */
  securityContext?: PodSecurityContext;
  /**
   * Redis container ports.
   */
  containerPorts?: {
    /**
     * Redis container port.
     */
    redis?: number;
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for Redis server pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Redis container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Redis service port.
   */
  servicePort?: number;
  /**
   * Priority class for redis pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules to the deployment.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to redis.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  service?: {
    /**
     * Redis service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * Additional redis service labels.
     */
    labels?: Record<string, string>;
  };
  metrics?: {
    /**
     * Deploy metrics service.
     */
    enabled?: boolean;
    /**
     * Redis metrics service configuration.
     */
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port.
       */
      servicePort?: number;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: ServiceMonitorConfig;
  };
}

/**
 * Redis-HA subchart configuration.
 * Ref: https://github.com/DandyDeveloper/charts/blob/master/charts/redis-ha/values.yaml
 */
export interface RedisHAConfig {
  /**
   * Enables the Redis HA subchart and disables the custom Redis single node deployment.
   */
  enabled?: boolean;
  /**
   * Redis image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Prometheus redis-exporter sidecar.
   */
  exporter?: {
    /**
     * Enable Prometheus redis-exporter sidecar.
     */
    enabled?: boolean;
    /**
     * Repository to use for the redis-exporter.
     */
    image?: string;
    /**
     * Tag to use for the redis-exporter.
     */
    tag?: string;
  };
  persistentVolume?: {
    /**
     * Configures persistence on Redis nodes.
     */
    enabled?: boolean;
  };
  /**
   * Redis specific configuration options.
   */
  redis?: {
    /**
     * Redis convention for naming the cluster group: must match `^[\\w-\\.]+$` and can be templated.
     */
    masterGroupName?: string;
    /**
     * Any valid redis config options in this section will be applied to each server (see `redis-ha` chart).
     * @default See [values.yaml]
     */
    config?: {
      /**
       * Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred. `""` is disabled.
       * @default '""'
       */
      save?: string;
      [key: string]: unknown;
    };
  };
  /**
   * Enables a HA Proxy for better LoadBalancing / Sentinel Master support. Automatically proxies to Redis master.
   */
  haproxy?: {
    /**
     * Enabled HAProxy LoadBalancing/Proxy.
     */
    enabled?: boolean;
    /**
     * Custom labels for the haproxy pod. This is relevant for Argo CD CLI.
     */
    labels?: Record<string, string>;
    image?: {
      /**
       * HAProxy Image Repository.
       */
      repository?: string;
    };
    metrics?: {
      /**
       * HAProxy enable prometheus metric scraping.
       */
      enabled?: boolean;
    };
    /**
     * Whether the haproxy pods should be forced to run on separate nodes.
     */
    hardAntiAffinity?: boolean;
    /**
     * Additional affinities to add to the haproxy pods.
     */
    additionalAffinities?: Record<string, unknown>;
    /**
     * Assign custom [affinity] rules to the haproxy pods.
     */
    affinity?: string;
    /**
     * [Tolerations] for use with node taints for haproxy pods.
     * {@link Toleration}
     */
    tolerations?: Toleration[];
    /**
     * HAProxy container-level security context.
     * @default See [values.yaml]
     * {@link ContainerSecurityContext}
     */
    containerSecurityContext?: ContainerSecurityContext;
  };
  /**
   * Configures redis-ha with AUTH.
   */
  auth?: boolean;
  /**
   * Existing Secret to use for redis-ha authentication.
   * By default the redis-secret-init Job is generating this Secret.
   */
  existingSecret?: string;
  /**
   * Whether the Redis server pods should be forced to run on separate nodes.
   */
  hardAntiAffinity?: boolean;
  /**
   * Additional affinities to add to the Redis server pods.
   */
  additionalAffinities?: Record<string, unknown>;
  /**
   * Assign custom [affinity] rules to the Redis pods.
   */
  affinity?: string;
  /**
   * [Tolerations] for use with node taints for Redis pods.
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [TopologySpreadConstraints] rules to the Redis pods.
   * https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
   */
  topologySpreadConstraints?: {
    /**
     * Enable Redis HA topology spread constraints.
     */
    enabled?: boolean;
    /**
     * Max skew of pods tolerated.
     * @default "" (defaults to `1`)
     */
    maxSkew?: number | string;
    /**
     * Topology key for spread.
     * @default "" (defaults to `topology.kubernetes.io/zone`)
     */
    topologyKey?: string;
    /**
     * Enforcement policy, hard or soft.
     * @default "" (defaults to `ScheduleAnyway`)
     */
    whenUnsatisfiable?: "DoNotSchedule" | "ScheduleAnyway";
  };
  /**
   * Redis HA statefulset container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
}

/**
 * AWS specific options for Application Load Balancer.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/#aws-application-load-balancers-albs-and-classic-elb-http-mode
 */
export interface IngressAWSConfig {
  /**
   * Backend protocol version for the AWS ALB gRPC service.
   * This tells AWS to send traffic from the ALB using gRPC.
   * For more information: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/target-group-health-checks.html#health-check-settings
   */
  backendProtocolVersion?: "GRPC" | "HTTP1" | "HTTP2";
  /**
   * Service type for the AWS ALB gRPC service.
   * Can be of type NodePort or ClusterIP depending on which mode you are running.
   * Instance mode needs type NodePort, IP mode needs type ClusterIP
   * Ref: https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.2/how-it-works/#ingress-traffic
   */
  serviceType?: "NodePort" | "ClusterIP";
}

/**
 * Google specific options for Google Application Load Balancer.
 * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/#google-cloud-load-balancers-with-kubernetes-ingress
 */
export interface IngressGKEConfig {
  /**
   * Google [BackendConfig] resource, for use with the GKE Ingress Controller.
   * @default {} (See [values.yaml])
   * Ref: https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#configuring_ingress_features_through_frontendconfig_parameters
   */
  backendConfig?: Record<string, unknown>;
  /**
   * Google [FrontendConfig] resource, for use with the GKE Ingress Controller.
   * @default {} (See [values.yaml])
   * Ref: https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#configuring_ingress_features_through_frontendconfig_parameters
   */
  frontendConfig?: Record<string, unknown>;
  /**
   * Managed GKE certificate for ingress hostname.
   */
  managedCertificate?: {
    /**
     * Create ManagedCertificate resource and annotations for Google Load balancer.
     * Ref: https://cloud.google.com/kubernetes-engine/docs/how-to/managed-certs
     */
    create?: boolean;
    /**
     * Additional domains for ManagedCertificate resource.
     */
    extraDomains?: string[];
  };
}

/**
 * Argo CD server ingress configuration.
 */
export interface IngressConfig {
  /**
   * Enable an ingress resource for the Argo CD server.
   */
  enabled?: boolean;
  /**
   * Specific implementation for ingress controller. One of `generic`, `aws` or `gke`.
   * Additional configuration might be required in related configuration sections.
   */
  controller?: "generic" | "aws" | "gke";
  /**
   * Additional ingress labels.
   */
  labels?: Record<string, string>;
  /**
   * Additional ingress annotations.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/#option-1-ssl-passthrough
   */
  annotations?: Record<string, string>;
  /**
   * Defines which ingress controller will implement the resource.
   */
  ingressClassName?: string;
  /**
   * Argo CD server hostname.
   * @default "" (defaults to global.domain)
   */
  hostname?: string;
  /**
   * The path to Argo CD server.
   */
  path?: string;
  /**
   * Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`.
   */
  pathType?: "Exact" | "Prefix" | "ImplementationSpecific";
  /**
   * Enable TLS configuration for the hostname defined at `server.ingress.hostname`.
   * TLS certificate will be retrieved from a TLS secret `argocd-server-tls`.
   * You can create this secret via `certificate` or `certificateSecret` option.
   */
  tls?: boolean;
  /**
   * The list of additional hostnames to be covered by ingress record.
   * @default [] (See [values.yaml])
   * {@link IngressHost}
   */
  extraHosts?: IngressHost[];
  /**
   * Additional ingress paths.
   * @default [] (See [values.yaml])
   * Note: Supports use of custom Helm templates.
   * {@link IngressPath}
   */
  extraPaths?: IngressPath[];
  /**
   * Additional ingress rules.
   * @default [] (See [values.yaml])
   * Note: Supports use of custom Helm templates.
   * {@link IngressRule}
   */
  extraRules?: IngressRule[];
  /**
   * Additional TLS configuration.
   * @default [] (See [values.yaml])
   * {@link IngressTLS}
   */
  extraTls?: IngressTLS[];
  /**
   * AWS specific options for Application Load Balancer.
   * {@link IngressAWSConfig}
   */
  aws?: IngressAWSConfig;
  /**
   * Google specific options for Google Application Load Balancer.
   * {@link IngressGKEConfig}
   */
  gke?: IngressGKEConfig;
}

/**
 * Certificate configuration using cert-manager.
 */
export interface CertManagerCertificateConfig {
  /**
   * Deploy a Certificate resource (requires cert-manager).
   */
  enabled?: boolean;
  /**
   * Certificate primary domain (commonName).
   * @default "" (defaults to global.domain)
   */
  domain?: string;
  /**
   * Certificate Subject Alternate Names (SANs).
   */
  additionalHosts?: string[];
  /**
   * The requested 'duration' (i.e. lifetime) of the certificate.
   * @default "" (defaults to 2160h = 90d if not specified)
   * Ref: https://cert-manager.io/docs/usage/certificate/#renewal
   */
  duration?: string;
  /**
   * How long before the expiry a certificate should be renewed.
   * @default "" (defaults to 360h = 15d if not specified)
   * Ref: https://cert-manager.io/docs/usage/certificate/#renewal
   */
  renewBefore?: string;
  /**
   * Certificate issuer.
   * Ref: https://cert-manager.io/docs/concepts/issuer
   */
  issuer?: {
    /**
     * Certificate issuer group. Set if using an external issuer. Eg. `cert-manager.io`.
     */
    group?: string;
    /**
     * Certificate issuer kind. Either `Issuer` or `ClusterIssuer`.
     */
    kind?: "Issuer" | "ClusterIssuer";
    /**
     * Certificate issuer name. Eg. `letsencrypt`.
     */
    name?: string;
  };
  /**
   * Private key of the certificate.
   */
  privateKey?: {
    /**
     * Rotation policy of private key when certificate is re-issued. Either: `Never` or `Always`.
     */
    rotationPolicy?: "Never" | "Always";
    /**
     * The private key cryptography standards (PKCS) encoding for private key. Either: `PCKS1` or `PKCS8`.
     */
    encoding?: "PKCS1" | "PKCS8";
    /**
     * Algorithm used to generate certificate private key. One of: `RSA`, `Ed25519` or `ECDSA`.
     */
    algorithm?: "RSA" | "Ed25519" | "ECDSA";
    /**
     * Key bit size of the private key. If algorithm is set to `Ed25519`, size is ignored.
     */
    size?: number;
  };
  /**
   * Annotations to be applied to the Certificate.
   */
  annotations?: Record<string, string>;
  /**
   * Usages for the certificate.
   * Ref: https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1.KeyUsage
   */
  usages?: string[];
  /**
   * Annotations that allow the certificate to be composed from data residing in existing Kubernetes Resources.
   */
  secretTemplateAnnotations?: Record<string, string>;
}

/**
 * Argo CD server configuration.
 */
export interface ServerConfig {
  /**
   * Argo CD server name.
   */
  name?: string;
  /**
   * The number of server pods to run.
   */
  replicas?: number;
  /**
   * Runtime class name for the Argo CD server.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * Argo CD server Horizontal Pod Autoscaler.
   * {@link HPAConfig}
   */
  autoscaling?: HPAConfig;
  /**
   * Argo CD server Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Argo CD server image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Additional command line arguments to pass to Argo CD server.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to Argo CD server.
   */
  env?: { name: string; value: string }[];
  /**
   * envFrom to pass to Argo CD server.
   * @default [] (See [values.yaml])
   */
  envFrom?: unknown[];
  /**
   * Specify postStart and preStop lifecycle hooks for your argo-cd-server container.
   */
  lifecycle?: Record<string, unknown>;
  /**
   * Argo CD extensions.
   * This function in tech preview stage, do expect instability or breaking changes in newer versions.
   * Ref: https://github.com/argoproj-labs/argocd-extension-installer
   * When you enable extensions, you need to configure RBAC of logged in Argo CD user.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/rbac/#the-extensions-resource
   */
  extensions?: {
    /**
     * Enable support for Argo CD extensions.
     */
    enabled?: boolean;
    /**
     * Argo CD extension installer image.
     * {@link ImageConfig}
     */
    image?: ImageConfig;
    /**
     * Extensions for Argo CD.
     * @default [] (See [values.yaml])
     * Ref: https://github.com/argoproj-labs/argocd-extension-metrics#install-ui-extension
     */
    extensionList?: {
      name: string;
      env: { name: string; value: string }[];
    }[];
    /**
     * Server UI extensions container-level security context.
     * @default See [values.yaml]
     * {@link ContainerSecurityContext}
     */
    containerSecurityContext?: ContainerSecurityContext;
    /**
     * Resource limits and requests for the argocd-extensions container.
     * {@link KubeResourceRequirement}
     */
    resources?: KubeResourceRequirement;
  };
  /**
   * Additional containers to be added to the server pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the server pod.
   * If your target Kubernetes cluster(s) require a custom credential (exec) plugin
   * you could use this (and the same in the application controller pod) to provide such executable.
   * Ref: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins
   */
  initContainers?: unknown[];
  /**
   * Additional volumeMounts to the server main container.
   * {@link VolumeMount}
   */
  volumeMounts?: VolumeMount[];
  /**
   * Additional volumes to the server pod.
   * {@link Volume}
   */
  volumes?: Volume[];
  /**
   * Argo CD server emptyDir volumes.
   */
  emptyDir?: {
    /**
     * EmptyDir size limit for the Argo CD server.
     * @default "" (defaults not set if not specified i.e. no size limit)
     */
    sizeLimit?: string;
  };
  /**
   * Annotations to be added to server Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be added to server pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be added to server pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the Argo CD server.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Server container ports.
   */
  containerPorts?: {
    /**
     * Server container port.
     */
    server?: number;
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * Host Network for Server pods.
   */
  hostNetwork?: boolean;
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for Server pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Server container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Readiness probe for default backend.
   * {@link ProbeConfig}
   */
  readinessProbe?: ProbeConfig;
  /**
   * Liveness probe for default backend.
   * {@link ProbeConfig}
   */
  livenessProbe?: ProbeConfig;
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * Priority class for the Argo CD server pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules to the deployment.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the Argo CD server.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the server Deployment.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
  /**
   * TLS certificate configuration via cert-manager.
   * {@link CertManagerCertificateConfig}
   */
  certificate?: CertManagerCertificateConfig;
  /**
   * TLS certificate configuration via Secret.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/tls/#tls-certificates-used-by-argocd-server
   */
  certificateSecret?: {
    /**
     * Create argocd-server-tls secret.
     */
    enabled?: boolean;
    /**
     * Annotations to be added to argocd-server-tls secret.
     */
    annotations?: Record<string, string>;
    /**
     * Labels to be added to argocd-server-tls secret.
     */
    labels?: Record<string, string>;
    /**
     * Private Key of the certificate.
     */
    key?: SecretValue<string>;
    /**
     * Certificate data.
     */
    crt?: string;
  };
  /**
   * Server service configuration.
   */
  service?: {
    /**
     * Server service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * Server service labels.
     */
    labels?: Record<string, string>;
    /**
     * Server service type.
     */
    type?: "ClusterIP" | "NodePort" | "LoadBalancer";
    /**
     * Server service http port for NodePort service type (only if `server.service.type` is set to "NodePort").
     */
    nodePortHttp?: number;
    /**
     * Server service https port for NodePort service type (only if `server.service.type` is set to "NodePort").
     */
    nodePortHttps?: number;
    /**
     * Server service http port.
     */
    servicePortHttp?: number;
    /**
     * Server service https port.
     */
    servicePortHttps?: number;
    /**
     * Server service http port name, can be used to route traffic via istio.
     */
    servicePortHttpName?: string;
    /**
     * Server service https port name, can be used to route traffic via istio.
     */
    servicePortHttpsName?: string;
    /**
     * Server service https port appProtocol.
     * Ref: https://kubernetes.io/docs/concepts/services-networking/service/#application-protocol
     */
    servicePortHttpsAppProtocol?: string;
    /**
     * The class of the load balancer implementation.
     */
    loadBalancerClass?: string;
    /**
     * LoadBalancer will get created with the IP specified in this field.
     */
    loadBalancerIP?: string;
    /**
     * Source IP ranges to allow access to service from.
     * EKS Ref: https://repost.aws/knowledge-center/eks-cidr-ip-address-loadbalancer
     * GKE Ref: https://cloud.google.com/kubernetes-engine/docs/concepts/network-overview#limit-connectivity-ext-lb
     */
    loadBalancerSourceRanges?: string[];
    /**
     * Server service external IPs.
     */
    externalIPs?: string[];
    /**
     * Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints.
     * Ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
     */
    externalTrafficPolicy?: "Cluster" | "Local";
    /**
     * Used to maintain session affinity. Supports `ClientIP` and `None`.
     * Ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
     */
    sessionAffinity?: "ClientIP" | "None";
  };
  /**
   * Server metrics service configuration.
   */
  metrics?: {
    /**
     * Deploy metrics service.
     */
    enabled?: boolean;
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port.
       */
      servicePort?: number;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: ServiceMonitorConfig;
  };
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Argo CD server ingress configuration.
   * {@link IngressConfig}
   */
  ingress?: IngressConfig;
  /**
   * Dedicated gRPC ingress for ingress controllers that supports only single backend protocol per Ingress resource.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/ingress/#option-2-multiple-ingress-objects-and-hosts
   * {@link IngressConfig}
   */
  ingressGrpc?: IngressConfig;
  /**
   * Create a OpenShift Route with SSL passthrough for UI and CLI.
   * Consider setting 'hostname' e.g. https://argocd.apps-crc.testing/ using your Default Ingress Controller Domain.
   * Find your domain with: kubectl describe --namespace=openshift-ingress-operator ingresscontroller/default | grep Domain:
   * If 'hostname' is an empty string "" OpenShift will create a hostname for you.
   */
  route?: {
    /**
     * Enable an OpenShift Route for the Argo CD server.
     */
    enabled?: boolean;
    /**
     * Openshift Route annotations.
     */
    annotations?: Record<string, string>;
    /**
     * Hostname of OpenShift Route.
     */
    hostname?: string;
    /**
     * Termination type of Openshift Route.
     */
    termination_type?: "passthrough" | "edge" | "reencrypt";
    /**
     * Termination policy of Openshift Route.
     */
    termination_policy?: "None" | "Redirect" | "Allow";
  };
  /**
   * Enable this and set the rules: to whatever custom rules you want for the Cluster Role resource.
   * Defaults to off.
   */
  clusterRoleRules?: {
    /**
     * Enable custom rules for the server's ClusterRole resource.
     */
    enabled?: boolean;
    /**
     * List of custom rules for the server's ClusterRole resource.
     */
    rules?: unknown[];
  };
}

/**
 * Repo server configuration.
 */
export interface RepoServerConfig {
  /**
   * Repo server name.
   */
  name?: string;
  /**
   * The number of repo server pods to run.
   */
  replicas?: number;
  /**
   * Runtime class name for the repo server.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * Repo server Horizontal Pod Autoscaler.
   * {@link HPAConfig}
   */
  autoscaling?: HPAConfig;
  /**
   * Repo server Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Repo server image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Additional command line arguments to pass to repo server.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to repo server.
   */
  env?: { name: string; value: string }[];
  /**
   * envFrom to pass to repo server.
   * @default [] (See [values.yaml])
   */
  envFrom?: unknown[];
  /**
   * Specify postStart and preStop lifecycle hooks for your argo-repo-server container.
   */
  lifecycle?: Record<string, unknown>;
  /**
   * Additional containers to be added to the repo server pod.
   * Ref: https://argo-cd.readthedocs.io/en/stable/user-guide/config-management-plugins/
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the repo server pods.
   */
  initContainers?: unknown[];
  /**
   * Additional volumeMounts to the repo server main container.
   * {@link VolumeMount}
   */
  volumeMounts?: VolumeMount[];
  /**
   * Additional volumes to the repo server pod.
   * {@link Volume}
   */
  volumes?: Volume[];
  /**
   * Volumes to be used in replacement of emptydir on default volumes.
   */
  existingVolumes?: Record<string, unknown>;
  /**
   * RepoServer emptyDir volumes.
   */
  emptyDir?: {
    /**
     * EmptyDir size limit for repo server.
     * @default "" (defaults not set if not specified i.e. no size limit)
     */
    sizeLimit?: string;
  };
  /**
   * Toggle the usage of a ephemeral Helm working directory.
   */
  useEphemeralHelmWorkingDir?: boolean;
  /**
   * Annotations to be added to repo server Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be added to repo server pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be added to repo server pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the repo server pods.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Repo server container ports.
   */
  containerPorts?: {
    /**
     * Repo server container port.
     */
    server?: number;
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * Host Network for Repo server pods.
   */
  hostNetwork?: boolean;
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for Repo server pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Repo server container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Readiness probe for default backend.
   * {@link ProbeConfig}
   */
  readinessProbe?: ProbeConfig;
  /**
   * Liveness probe for default backend.
   * {@link ProbeConfig}
   */
  livenessProbe?: ProbeConfig;
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules to the deployment.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the repo server.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the repo server Deployment.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
  /**
   * Priority class for the repo server pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * TLS certificate configuration via Secret.
   * Ref: https://argo-cd.readthedocs.io/en/stable/operator-manual/tls/#configuring-tls-to-argocd-repo-server
   * Note: Issuing certificates via cert-manager in not supported right now because it's not possible to restart repo server automatically without extra controllers.
   */
  certificateSecret?: {
    /**
     * Create argocd-repo-server-tls secret.
     */
    enabled?: boolean;
    /**
     * Annotations to be added to argocd-repo-server-tls secret.
     */
    annotations?: Record<string, string>;
    /**
     * Labels to be added to argocd-repo-server-tls secret.
     */
    labels?: Record<string, string>;
    /**
     * Certificate authority. Required for self-signed certificates.
     */
    ca?: string;
    /**
     * Certificate private key.
     */
    key?: SecretValue<string>;
    /**
     * Certificate data. Must contain SANs of Repo service (ie: argocd-repo-server, argocd-repo-server.argo-cd.svc).
     */
    crt?: string;
  };
  /**
   * Repo server service configuration.
   */
  service?: {
    /**
     * Repo server service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * Repo server service labels.
     */
    labels?: Record<string, string>;
    /**
     * Repo server service port.
     */
    port?: number;
    /**
     * Repo server service port name.
     */
    portName?: string;
  };
  /**
   * Repo server metrics service configuration.
   */
  metrics?: {
    /**
     * Deploy metrics service.
     */
    enabled?: boolean;
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port.
       */
      servicePort?: number;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: ServiceMonitorConfig;
  };
  /**
   * Enable Custom Rules for the Repo server's Cluster Role resource.
   */
  clusterRoleRules?: {
    /**
     * Enable custom rules for the Repo server's Cluster Role resource.
     */
    enabled?: boolean;
    /**
     * List of custom rules for the Repo server's Cluster Role resource.
     */
    rules?: unknown[];
  };
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Repo server service account.
   * If create is set to true, make sure to uncomment the name and update the rbac section below.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Repo server rbac rules.
   */
  rbac?: unknown[];
}

/**
 * ApplicationSet controller configuration.
 */
export interface ApplicationSetControllerConfig {
  /**
   * ApplicationSet controller name string.
   */
  name?: string;
  /**
   * The number of ApplicationSet controller pods to run.
   */
  replicas?: number;
  /**
   * Runtime class name for the ApplicationSet controller.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * ApplicationSet controller Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * ApplicationSet controller image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * If defined, uses a Secret to pull an image from a private Docker registry or repository.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * ApplicationSet controller command line flags.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to the ApplicationSet controller.
   */
  extraEnv?: { name: string; value: string }[];
  /**
   * envFrom to pass to the ApplicationSet controller.
   * @default [] (See [values.yaml])
   */
  extraEnvFrom?: unknown[];
  /**
   * Additional containers to be added to the ApplicationSet controller pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the ApplicationSet controller pod.
   * Note: Supports use of custom Helm templates.
   */
  initContainers?: unknown[];
  /**
   * List of extra mounts to add (normally used with extraVolumes).
   * {@link VolumeMount}
   */
  extraVolumeMounts?: VolumeMount[];
  /**
   * List of extra volumes to add.
   * {@link Volume}
   */
  extraVolumes?: Volume[];
  /**
   * ApplicationSet controller emptyDir volumes.
   */
  emptyDir?: {
    /**
     * EmptyDir size limit for applicationSet controller.
     * @default "" (defaults not set if not specified i.e. no size limit)
     */
    sizeLimit?: string;
  };
  /**
   * Metrics service configuration.
   */
  metrics?: {
    /**
     * Deploy metrics service.
     */
    enabled?: boolean;
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port.
       */
      servicePort?: number;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: ServiceMonitorConfig;
  };
  /**
   * ApplicationSet service configuration.
   */
  service?: {
    /**
     * ApplicationSet service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * ApplicationSet service labels.
     */
    labels?: Record<string, string>;
    /**
     * ApplicationSet service type.
     */
    type?: "ClusterIP" | "NodePort" | "LoadBalancer";
    /**
     * ApplicationSet service port.
     */
    port?: number;
    /**
     * ApplicationSet service port name.
     */
    portName?: string;
  };
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Annotations to be added to ApplicationSet controller Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations for the ApplicationSet controller pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels for the ApplicationSet controller pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the ApplicationSet controller pods.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * ApplicationSet controller container ports.
   */
  containerPorts?: {
    /**
     * Metrics container port.
     */
    metrics?: number;
    /**
     * Probe container port.
     */
    probe?: number;
    /**
     * Webhook container port.
     */
    webhook?: number;
  };
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for ApplicationSet controller pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * ApplicationSet controller container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Probes for ApplicationSet controller (optional).
   */
  readinessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * Probes for ApplicationSet controller (optional).
   */
  livenessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the ApplicationSet controller.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the ApplicationSet controller Deployment.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
  /**
   * Priority class for the ApplicationSet controller pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * TLS certificate configuration via cert-manager.
   * {@link CertManagerCertificateConfig}
   */
  certificate?: CertManagerCertificateConfig;
  /**
   * Ingress for the Git Generator webhook.
   * Ref: https://argocd-applicationset.readthedocs.io/en/master/Generators-Git/#webhook-configuration)
   * {@link IngressConfig}
   */
  ingress?: IngressConfig;
  /**
   * Enable ApplicationSet in any namespace feature.
   */
  allowAnyNamespace?: boolean;
}

/**
 * Notifications controller configuration.
 */
export interface NotificationsConfig {
  /**
   * Enable notifications controller.
   */
  enabled?: boolean;
  /**
   * Notifications controller name string.
   */
  name?: string;
  /**
   * Argo CD dashboard url; used in place of {{.context.argocdUrl}} in templates.
   * @default "" (defaults to https://`global.domain`)
   */
  argocdUrl?: string;
  /**
   * Runtime class name for the notifications controller.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * Notifications controller Pod Disruption Budget.
   * {@link PDBConfig}
   */
  pdb?: PDBConfig;
  /**
   * Notifications controller image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * Secrets with credentials to pull images from a private registry.
   * @default [] (defaults to global.imagePullSecrets)
   */
  imagePullSecrets?: { name: string }[];
  /**
   * Extra arguments to provide to the notifications controller.
   */
  extraArgs?: string[];
  /**
   * Additional container environment variables.
   */
  extraEnv?: { name: string; value: string }[];
  /**
   * envFrom to pass to the notifications controller.
   * @default [] (See [values.yaml])
   */
  extraEnvFrom?: unknown[];
  /**
   * Additional containers to be added to the notifications controller pod.
   * Note: Supports use of custom Helm templates.
   */
  extraContainers?: unknown[];
  /**
   * Init containers to add to the notifications controller pod.
   * Note: Supports use of custom Helm templates.
   */
  initContainers?: unknown[];
  /**
   * List of extra mounts to add (normally used with extraVolumes).
   * {@link VolumeMount}
   */
  extraVolumeMounts?: VolumeMount[];
  /**
   * List of extra volumes to add.
   * {@link Volume}
   */
  extraVolumes?: Volume[];
  /**
   * Define user-defined context.
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/templates/#defining-user-defined-context
   */
  context?: Record<string, string>;
  secret?: {
    /**
     * Whether helm chart creates notifications controller secret.
     * If true, will create a secret with the name below. Otherwise, will assume existence of a secret with that name.
     */
    create?: boolean;
    /**
     * notifications controller Secret name.
     */
    name?: string;
    /**
     * key:value pairs of annotations to be added to the secret.
     */
    annotations?: Record<string, string>;
    /**
     * key:value pairs of labels to be added to the secret.
     */
    labels?: Record<string, string>;
    /**
     * Generic key:value pairs to be inserted into the secret.
     * Can be used for templates, notification services etc.
     * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/services/overview/
     */
    items?: Record<string, SecretValue<string>>;
  };
  metrics?: {
    /**
     * Enables prometheus metrics server.
     */
    enabled?: boolean;
    /**
     * Metrics port.
     */
    port?: number;
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
    /**
     * Service monitor configuration.
     * {@link ServiceMonitorConfig}
     */
    serviceMonitor?: Omit<ServiceMonitorConfig, "scrapeTimeout">;
  };
  /**
   * Configures notification services such as slack, email or custom webhook.
   * @default See [values.yaml]
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/services/overview/
   */
  notifiers?: Record<string, string>;
  /**
   * Annotations to be applied to the notifications controller Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations to be applied to the notifications controller Pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels to be applied to the notifications controller Pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the notifications controller.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * Notification controller container ports.
   */
  containerPorts?: {
    /**
     * Metrics container port.
     */
    metrics?: number;
  };
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for notifications controller Pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * Notification controller container-level security Context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Probes for notifications controller Pods (optional).
   */
  readinessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * Probes for notifications controller Pods (optional).
   */
  livenessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the application controller.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the notifications controller Deployment.
   */
  deploymentStrategy?: {
    type?: "Recreate" | "RollingUpdate";
  };
  /**
   * Priority class for the notifications controller pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  cm?: {
    /**
     * Whether helm chart creates notifications controller config map.
     */
    create?: boolean;
  };
  /**
   * Enable this and set the rules: to whatever custom rules you want for the Cluster Role resource.
   * Defaults to off.
   */
  clusterRoleRules?: {
    /**
     * List of custom rules for the notifications controller's ClusterRole resource.
     */
    rules?: unknown[];
  };
  /**
   * Contains centrally managed global application subscriptions.
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/subscriptions/
   */
  subscriptions?: unknown[];
  /**
   * The notification template is used to generate the notification content.
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/templates/
   */
  templates?: Record<string, string>;
  /**
   * The trigger defines the condition when the notification should be sent.
   * For more information: https://argo-cd.readthedocs.io/en/stable/operator-manual/notifications/triggers/
   */
  triggers?: Record<string, string>;
}

/**
 * Commit server configuration.
 */
export interface CommitServerConfig {
  /**
   * Enable commit server.
   */
  enabled?: boolean;
  /**
   * Commit server name.
   */
  name?: string;
  /**
   * Runtime class name for the commit server.
   * @default "" (defaults to global.runtimeClassName)
   */
  runtimeClassName?: string;
  /**
   * commit server controller image.
   * {@link ImageConfig}
   */
  image?: ImageConfig;
  /**
   * commit server command line flags.
   */
  extraArgs?: string[];
  /**
   * Environment variables to pass to the commit server.
   */
  extraEnv?: { name: string; value: string }[];
  /**
   * envFrom to pass to the commit server.
   * @default [] (See [values.yaml])
   */
  extraEnvFrom?: unknown[];
  /**
   * List of extra mounts to add (normally used with extraVolumes).
   * {@link VolumeMount}
   */
  extraVolumeMounts?: VolumeMount[];
  /**
   * List of extra volumes to add.
   * {@link Volume}
   */
  extraVolumes?: Volume[];
  metrics?: {
    /**
     * Enables prometheus metrics server.
     */
    enabled?: boolean;
    service?: {
      /**
       * Metrics service type.
       */
      type?: "ClusterIP" | "NodePort" | "LoadBalancer";
      /**
       * Metrics service clusterIP. `None` makes a "headless service" (no virtual IP).
       */
      clusterIP?: string;
      /**
       * Metrics service annotations.
       */
      annotations?: Record<string, string>;
      /**
       * Metrics service labels.
       */
      labels?: Record<string, string>;
      /**
       * Metrics service port.
       */
      servicePort?: number;
      /**
       * Metrics service port name.
       */
      portName?: string;
    };
  };
  /**
   * commit server service configuration.
   */
  service?: {
    /**
     * commit server service annotations.
     */
    annotations?: Record<string, string>;
    /**
     * commit server service labels.
     */
    labels?: Record<string, string>;
  };
  /**
   * Automount API credentials for the Service Account into the pod.
   */
  automountServiceAccountToken?: boolean;
  /**
   * Service account configuration.
   * {@link ServiceAccountConfig}
   */
  serviceAccount?: ServiceAccountConfig;
  /**
   * Annotations to be added to commit server Deployment.
   */
  deploymentAnnotations?: Record<string, string>;
  /**
   * Annotations for the commit server pods.
   */
  podAnnotations?: Record<string, string>;
  /**
   * Labels for the commit server pods.
   */
  podLabels?: Record<string, string>;
  /**
   * Resource limits and requests for the commit server pods.
   * {@link KubeResourceRequirement}
   */
  resources?: KubeResourceRequirement;
  /**
   * [DNS configuration].
   */
  dnsConfig?: Record<string, unknown>;
  /**
   * Alternative DNS policy for commit server pods.
   */
  dnsPolicy?: "ClusterFirst" | "Default" | "None" | "ClusterFirstWithHostNet";
  /**
   * commit server container-level security context.
   * @default See [values.yaml]
   * {@link ContainerSecurityContext}
   */
  containerSecurityContext?: ContainerSecurityContext;
  /**
   * Probes for commit server (optional).
   */
  readinessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * Probes for commit server (optional).
   */
  livenessProbe?: ProbeConfig & { enabled?: boolean };
  /**
   * terminationGracePeriodSeconds for container lifecycle hook.
   */
  terminationGracePeriodSeconds?: number;
  /**
   * [Node selector].
   * @default {} (defaults to global.nodeSelector)
   */
  nodeSelector?: Record<string, string>;
  /**
   * [Tolerations] for use with node taints.
   * @default [] (defaults to global.tolerations)
   * {@link Toleration}
   */
  tolerations?: Toleration[];
  /**
   * Assign custom [affinity] rules.
   * @default {} (defaults to global.affinity preset)
   */
  affinity?: Record<string, unknown>;
  /**
   * Assign custom [TopologySpreadConstraints] rules to the commit server.
   * @default [] (defaults to global.topologySpreadConstraints)
   * {@link TopologySpreadConstraint}
   */
  topologySpreadConstraints?: TopologySpreadConstraint[];
  /**
   * Deployment strategy to be added to the commit server Deployment.
   */
  deploymentStrategy?: {
    type?: "RollingUpdate" | "Recreate";
    rollingUpdate?: {
      maxSurge?: string | number;
      maxUnavailable?: string | number;
    };
  };
  /**
   * Priority class for the commit server pods.
   * @default "" (defaults to global.priorityClassName)
   */
  priorityClassName?: string;
}

/**
 * Models the ArgoCD Helm chart `values.yaml` file.
 * Ref: https://github.com/argoproj/argo-cd
 */
export interface ArgoCDChartValues {
  /**
   * Provide a name in place of `argocd`.
   */
  nameOverride?: string;
  /**
   * String to fully override `"argo-cd.fullname"`.
   */
  fullnameOverride?: string;
  /**
   * Override the namespace.
   * @default .Release.Namespace
   */
  namespaceOverride?: string;
  /**
   * Override the Kubernetes version, which is used to evaluate certain manifests.
   */
  kubeVersionOverride?: string;
  /**
   * Override APIVersions.
   * If you want to template helm charts but cannot access k8s API server
   * you can set api versions here.
   */
  apiVersionOverrides?: Record<string, unknown>;
  /**
   * Create aggregated roles that extend existing cluster roles to interact with argo-cd resources.
   * Ref: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles
   */
  createAggregateRoles?: boolean;
  /**
   * Create cluster roles for cluster-wide installation.
   * Used when you manage applications in the same cluster where Argo CD runs.
   */
  createClusterRoles?: boolean;
  /**
   * OpenShift specific configuration.
   */
  openshift?: {
    /**
     * enables using arbitrary uid for argo repo server.
     */
    enabled?: boolean;
  };
  /**
   * Custom resource configuration.
   */
  crds?: {
    /**
     * Install and upgrade CRDs.
     */
    install?: boolean;
    /**
     * Keep CRDs on chart uninstall.
     */
    keep?: boolean;
    /**
     * Annotations to be added to all CRDs.
     */
    annotations?: Record<string, string>;
    /**
     * Addtional labels to be added to all CRDs.
     */
    additionalLabels?: Record<string, string>;
  };
  /**
   * Globally shared configuration.
   * {@link GlobalConfig}
   */
  global?: GlobalConfig;
  /**
   * Argo Configs.
   * {@link ArgoCDConfigs}
   */
  configs?: ArgoCDConfigs;
  /**
   * Array of extra K8s manifests to deploy.
   * Note: Supports use of custom Helm templates.
   */
  extraObjects?: unknown[];
  /**
   * Application controller configuration.
   * {@link ControllerConfig}
   */
  controller?: ControllerConfig;
  /**
   * Dex server configuration.
   * {@link DexConfig}
   */
  dex?: DexConfig;
  /**
   * Redis configuration.
   * {@link RedisConfig}
   */
  redis?: RedisConfig;
  /**
   * Redis-HA subchart configuration.
   * {@link RedisHAConfig}
   */
  "redis-ha"?: RedisHAConfig;
  /**
   * External Redis parameters.
   */
  externalRedis?: {
    /**
     * External Redis server host.
     */
    host?: string;
    /**
     * External Redis username.
     */
    username?: string;
    /**
     * External Redis password.
     */
    password?: SecretValue<string>;
    /**
     * External Redis server port.
     */
    port?: number;
    /**
     * The name of an existing secret with Redis (must contain key `redis-password`) and Sentinel credentials.
     * When it's set, the `externalRedis.password` parameter is ignored.
     */
    existingSecret?: string;
    /**
     * External Redis Secret annotations.
     */
    secretAnnotations?: Record<string, string>;
  };
  /**
   * Redis secret initialization job configuration.
   */
  redisSecretInit?: {
    /**
     * Enable Redis secret initialization. If disabled, secret must be provisioned by alternative methods.
     */
    enabled?: boolean;
    /**
     * Redis secret-init name.
     */
    name?: string;
    /**
     * Redis secret-init image configuration.
     * {@link ImageConfig}
     */
    image?: ImageConfig;
    /**
     * Secrets with credentials to pull images from a private registry.
     * @default [] (defaults to global.imagePullSecrets)
     */
    imagePullSecrets?: { name: string }[];
    /**
     * Annotations to be added to the Redis secret-init Job.
     */
    jobAnnotations?: Record<string, string>;
    /**
     * Annotations to be added to the Redis secret-init Job.
     */
    podAnnotations?: Record<string, string>;
    /**
     * Labels to be added to the Redis secret-init Job.
     */
    podLabels?: Record<string, string>;
    /**
     * Resource limits and requests for Redis secret-init Job.
     * {@link KubeResourceRequirement}
     */
    resources?: KubeResourceRequirement;
    /**
     * Application controller container-level security context.
     * @default See [values.yaml]
     * {@link ContainerSecurityContext}
     */
    containerSecurityContext?: ContainerSecurityContext;
    /**
     * Redis secret-init Job pod-level security context.
     * {@link PodSecurityContext}
     */
    securityContext?: PodSecurityContext;
    /**
     * Service account for redis secret-init job.
     * {@link ServiceAccountConfig}
     */
    serviceAccount?: ServiceAccountConfig;
    /**
     * Priority class for Redis secret-init Job.
     * @default "" (defaults to global.priorityClassName)
     */
    priorityClassName?: string;
    /**
     * Assign custom [affinity] rules to the Redis secret-init Job.
     */
    affinity?: Record<string, unknown>;
    /**
     * Node selector to be added to the Redis secret-init Job.
     * @default {} (defaults to global.nodeSelector)
     */
    nodeSelector?: Record<string, string>;
    /**
     * Tolerations to be added to the Redis secret-init Job.
     * @default [] (defaults to global.tolerations)
     * {@link Toleration}
     */
    tolerations?: Toleration[];
  };
  /**
   * Argo CD server configuration.
   * {@link ServerConfig}
   */
  server?: ServerConfig;
  /**
   * Repo server configuration.
   * {@link RepoServerConfig}
   */
  repoServer?: RepoServerConfig;
  /**
   * ApplicationSet controller configuration.
   * {@link ApplicationSetControllerConfig}
   */
  applicationSet?: ApplicationSetControllerConfig;
  /**
   * Notifications controller configuration.
   * {@link NotificationsConfig}
   */
  notifications?: NotificationsConfig;
  /**
   * Commit server configuration.
   * {@link CommitServerConfig}
   */
  commitServer?: CommitServerConfig;
}
