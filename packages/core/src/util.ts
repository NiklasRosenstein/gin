import { assert } from "@std/assert/assert";
import StackTracey from "stacktracey";

// When we describe the origin of a resource, we need to split it into multiple labels because Kubernetes label
// values cannot contain slashes.
export const GIN_ORIGIN_APIGROUP = "origin.core.gin.jsr.io/api-group";
export const GIN_ORIGIN_APIVERSION = "origin.core.gin.jsr.io/api-version";
export const GIN_ORIGIN_KIND = "origin.core.gin.jsr.io/kind";
export const GIN_ORIGIN_NAME = "origin.core.gin.jsr.io/name";
export const GIN_ORIGIN_NAMESPACE = "origin.core.gin.jsr.io/namespace";

/**
 * Returns an object that contains labels to describe what Gin-specific resource another resource was generated from.
 * This label is assigned automatically to all resources generated by Gin, but there are cases where a resource adapter
 * may want to generate this label manually.
 *
 * @param resource - The resource from which the label is generated, containing `apiVersion`, `kind`, and `metadata`.
 */
export function makeOriginLabels(
  resource: { apiVersion: string; kind: string; metadata: { name: string; namespace?: string } },
): Record<string, string> {
  const apiGroup = resource.apiVersion.split("/")[0] || "";
  const apiVersion = resource.apiVersion.split("/")[1] || "";

  assert(
    isValidKubernetesLabelValue(apiGroup),
    `Unexpected API group value cannot be used as Kubernetes label value: ${apiGroup}`,
  );
  assert(
    isValidKubernetesLabelValue(apiVersion),
    `Unexpected API version value cannot be used as Kubernetes label value: ${apiVersion}`,
  );
  assert(
    isValidKubernetesLabelValue(resource.kind),
    `Unexpected Kind value cannot be used as Kubernetes label value: ${resource.kind}`,
  );
  assert(
    isValidKubernetesLabelValue(resource.metadata.name),
    `Unexpected Name value cannot be used as Kubernetes label value: ${resource.kind}`,
  );
  assert(
    !resource.metadata.namespace || isValidKubernetesLabelValue(resource.metadata.namespace),
    `Unexpected Namespace value cannot be used as Kubernetes label value: ${resource.metadata.namespace}`,
  );

  return {
    [GIN_ORIGIN_APIGROUP]: apiGroup,
    [GIN_ORIGIN_APIVERSION]: apiVersion,
    [GIN_ORIGIN_KIND]: resource.kind,
    [GIN_ORIGIN_NAME]: resource.metadata.name,
    ...(
      resource.metadata.namespace ? { [GIN_ORIGIN_NAMESPACE]: resource.metadata.namespace } : {}
    ),
  };
}

/**
 * Validates that a string is fit as a value for a Kubernetes label.
 *
 * See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
 */
export function isValidKubernetesLabelValue(value: string): boolean {
  if (value.length > 63) {
    return false; // Kubernetes label values must be 63 characters or less
  }
  return /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/.test(value);
}

/**
 * Returns the filename and line number of the caller of this function.
 */
export function getCallerFileAndLine(depth: number = 1): string {
  const trace = new StackTracey(new Error());
  const file = trace.items[depth + 1]?.file || "<unknown>";
  const line = trace.items[depth + 1]?.line || "??";
  return `${file}:${line}`;
}

/**
 * Recursively drop keys from the object that have value `undefined`.
 */
export function dropUndefined<T extends unknown>(obj: T): T {
  if (Array.isArray(obj)) {
    return obj.map(dropUndefined) as T;
  } else if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([_, v]) => v !== undefined)
        .map(([k, v]) => [k, dropUndefined(v)]),
    ) as T;
  }
  return obj;
}

/**
 * Create a temporary directory that will be cleaned up when the Deno process exits. Note that
 * this directory may be left behind if the process is killed or crashes.
 */
export async function createManagedTempDir(prefix: string): Promise<string> {
  const dir = await Deno.makeTempDir({ prefix });
  globalThis.addEventListener("unload", () => {
    try {
      // NOTE: If we use the async variant, not all file will be removed before the process exits.
      Deno.removeSync(dir, { recursive: true });
    } catch (e) {
      console.warn(`Failed to remove temporary directory ${dir}:`, e);
    }
  });
  return dir;
}
